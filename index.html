<!DOCTYPE html>
<html>
<head>
  <title></title>
	<style type="text/css">
	</style>
</head>
<body>
	<canvas id="canvas"></canvas>


<script type="text/javascript">
	window.onload = function() {
		//general variables
		var canvas = document.getElementById("canvas");
		var ctx = canvas.getContext("2d");
		var W = 500, H = 300;
		canvas.width = W;
		canvas.height = H;

		var fps = 30;

		//actor variables
		var ourShip;
		var shipRotation = 0;
		var shipXScale = 1;

		var stars = [];
		var starCount = 100;
		var starSpeedQuotient = 0;

		var particles = [];
		var particleCount = 100;

		//keypress variables
		var tickRate = 30,
    keyArrowUp    = false,
    keyArrowDown  = false,
    keyArrowLeft  = false,
    keyArrowRight = false;

    //call constructor class
		init();		

		function init() {
			//create ship;
 			ourShip = new ship();

 			//create stars;
			for(var i = 0; i < starCount; i++) 
			{
				stars.push(new star(true));
			}

			// create particles
			for(var i = 0; i < particleCount; i++) 
			{
				particles.push(new particle());
			}

			setInterval(draw, fps);		
		};

		function convertToRadians(degree) {
    	return degree*(Math.PI/180);
    };

		//draw the stage
		function draw() {

			var s = ourShip;
			//draw BG
			ctx.globalCompositeOperation ="source-over";
			ctx.fillStyle = "black";
			ctx.fillRect(0,0,W,H);
			

			//draw stars
			for(var i = 0; i < stars.length; i++) {
				var st = stars[i];
				ctx.fillStyle = "rgba(255,255,255,"+st.opacity+")";
				ctx.fillRect(st.location.x, st.location.y, st.size*4, st.size*4);

				//calculate star speed

					var oldRange = (8 - -8);  
					var newRange = (5 - 1);  
					var newSpeed = (((-starSpeedQuotient - -8) * newRange) / oldRange) + 1;
					st.location.y += st.speed * newSpeed; 

				// regenerate lost stars
				if(st.location.y > H) {
					//create new star at top
					stars[i] = new star();
				}
			}

			ctx.globalCompositeOperation ="lighter";

			//draw particles
			for(var i=0;i<particles.length; i++)
			{
				var p = particles[i];
				p.opacity = Math.round(p.remaining_life/p.life*100)/100;

				ctx.fillStyle = "rgba("+p.r+","+p.g+","+p.b+","+p.opacity+")";
				ctx.fillRect(p.location.x, p.location.y, p.radius, p.radius);
				ctx.fill();

				// move the particles
				p.remaining_life--;
				p.radius--;
				p.location.x += p.speed.x;
				p.location.y -= p.speed.y;

				// regenerate particles
				if(p.remaining_life < 0)
				{
					//create new particle to replace old one
					particles[i] = new particle();
				}	
			}

			ctx.globalCompositeOperation ="source-over";

			ctx.save();
			ctx.translate(s.location.x, s.location.y);
			ctx.rotate(convertToRadians(shipRotation));
			ctx.translate( -s.size.w/2, -s.size.h/2);
			// draw ship
			ctx.drawImage(ourShip.img,0,0, s.size.w * shipXScale, s.size.h);
			ctx.restore();
		};

		//ship actor
		function ship()	{
			this.location = {x: W/2, y: H/2};
			this.speed = 0.5;
			this.v = {x: 0, y:0};
			this.friction = 0.93;
			this.size = {w: 60, h: 60};
			this.maxSpeed = 8;
			this.img = new Image();
			this.img.src = 'ship.png';

			//key press event listeners
			window.addEventListener( "keydown", onKeyDown, true );
			window.addEventListener("keyup", onKeyUp, true);

			function onKeyDown(e) {
				var k = e.keyCode;
				if (k == 37) {
					keyArrowLeft = true;
				} else if(k == 39) {
					keyArrowRight = true;
				}
				if (k == 38) {
					keyArrowUp = true;
				} else if (k == 40) {
					keyArrowDown = true;
				}
			};

			function onKeyUp(e) {
				var k = e.keyCode;
				if (k == 37) {
					keyArrowLeft = false;				
				} else if(k == 39) {
					keyArrowRight = false;
				}
				if (k == 38) {
					keyArrowUp = false;
				} else if (k == 40) {
					keyArrowDown = false;
				}
			};

			function loop() {

				var s = ourShip;

				//handle keypresses
			  if (keyArrowUp) 
			  	s.v.y -= s.speed;
			   else if (keyArrowDown) 
					s.v.y += s.speed;
			   else 
			  	s.v.y *= s.friction;
			  

			  if (keyArrowLeft) 
			    s.v.x -= s.speed;
			  else if (keyArrowRight) 
			    s.v.x += s.speed;
			  else 
			  	s.v.x *= s.friction;			 

			  //update location
			  s.location.x += s.v.x;
			  s.location.y += s.v.y;

			  //limit speed
			  if (s.v.x > s.maxSpeed)
					s.v.x = s.maxSpeed;
				else if (s.v.x < -s.maxSpeed)
					s.v.x = -s.maxSpeed;
	 
				if (s.v.y > s.maxSpeed)
					s.v.y = s.maxSpeed;
				else if (s.v.y < -s.maxSpeed)
					s.v.y = -s.maxSpeed;

			  //set appearance variables
			  shipRotation = s.v.x;
			  shipXScale = (s.maxSpeed - Math.abs(s.v.x))/(s.maxSpeed*4)+0.75;	

			  //limit movement within the canvas
			  if (s.location.x > W) {
			  	s.location.x = W;
			  	s.v.x = -s.v.x;
			  } else if (s.location.x < 0) {
			  	s.location.x = 0;
			  	s.v.x = -s.v.x;
			  }

			  if (s.location.y > H) {
			  	s.location.y = H;
		  		s.v.y = -s.v.y;
			  } else if (s.location.y < 0) {
			  	s.location.y = 0;
			  	s.v.y = -s.v.y;
				}

				starSpeedQuotient = s.v.y;	  

			};

			setInterval(loop, fps);

		};

		//star actor
		function star(randomizeY) {
			this.location = {x: Math.random()*W, y: randomizeY ? Math.random()*H : 0};
			this.opacity = Math.random();
			this.size = Math.random() + 0.2;
			this.speed = 3 + Math.random() * 2;
		}

		//particle effect
		function particle()
		{
			//speed, life, location
			//speed range = -2.5 to 2.5
			this.speed = {x: -2 + Math.random()*4, y: -15 + Math.random()*10};

			// radius range 10 to 30
			this.radius = 15 + Math.random()*10;

			//location = center of screen
			this.location = {x: ourShip.location.x - this.radius/2, y: ourShip.location.y - this.radius/2 + 30};
			
			// life range 20 to 30
			this.life = 1+Math.random()*10;
			this.remaining_life = this.life;

			// colours
			this.r = Math.round(255);
			this.g = Math.round(Math.random()*255);
			this.b = Math.round(Math.random()*255);

		}
	
	}
</script>
</body>
</html>
